/**
 * Generated by @openapi-codegen
 *
 * @version 0.0.1
 */
import * as reactQuery from "react-query";
import { useCuredaoContext, CuredaoContext } from "./curedaoContext";
import type * as Fetcher from "./curedaoFetcher";
import { curedaoFetch } from "./curedaoFetcher";
import type * as Schemas from "./curedaoSchemas";
import type * as RequestBodies from "./curedaoRequestBodies";

export type GetUnitsError = Fetcher.ErrorWrapper<undefined>;

export type GetUnitsResponse = Schemas.Unit[];

export type GetUnitsVariables = CuredaoContext["fetcherOptions"];

/**
 * Get a list of the available measurement units
 */
export const fetchGetUnits = (variables: GetUnitsVariables) =>
  curedaoFetch<GetUnitsResponse, GetUnitsError, undefined, {}, {}, {}>({
    url: "/v3/units",
    method: "get",
    ...variables,
  });

/**
 * Get a list of the available measurement units
 */
export const useGetUnits = (
  variables: GetUnitsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetUnitsResponse,
      GetUnitsError,
      GetUnitsResponse
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useCuredaoContext(options);
  return reactQuery.useQuery<GetUnitsResponse, GetUnitsError, GetUnitsResponse>(
    queryKeyFn({ path: "/v3/units", operationId: "getUnits", variables }),
    () => fetchGetUnits({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type GetVariablesQueryParams = {
  /*
   * Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
   */
  includeCharts?: boolean;
  /*
   * Filter variables by the total number of measurements that they have. This could be used of you want to filter or sort by popularity.
   */
  numberOfRawMeasurements?: string;
  /*
   * User's id
   */
  userId?: number;
  /*
   * Ex: Emotions, Treatments, Symptoms...
   */
  variableCategoryName?:
    | "Activities"
    | "Books"
    | "Causes of Illness"
    | "Cognitive Performance"
    | "Conditions"
    | "Emotions"
    | "Environment"
    | "Foods"
    | "Location"
    | "Miscellaneous"
    | "Movies and TV"
    | "Music"
    | "Nutrients"
    | "Payments"
    | "Physical Activity"
    | "Physique"
    | "Sleep"
    | "Social Interactions"
    | "Software"
    | "Symptoms"
    | "Treatments"
    | "Vital Signs"
    | "Goals";
  /*
   * Name of the variable. To get results matching a substring, add % as a wildcard as the first and/or last character of a query string parameter. In order to get variables that contain `Mood`, the following query should be used: ?variableName=%Mood%
   */
  name?: string;
  /*
   * Name of the variable you want measurements for
   */
  variableName?: string;
  /*
   * When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
   */
  updatedAt?: string;
  /*
   * ID of the source you want measurements for (supports exact name match only)
   */
  sourceName?: string;
  /*
   * Excluded records with measurement times earlier than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
   */
  earliestMeasurementTime?: string;
  /*
   * Excluded records with measurement times later than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
   */
  latestMeasurementTime?: string;
  /*
   * Common variable id
   */
  id?: number;
  /*
   * Limit variables to those which measurements were last submitted by a specific source. So if you have a client application and you only want variables that were last updated by your app, you can include the name of your app here
   */
  lastSourceName?: string;
  /*
   * The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
   *
   * @default 100
   */
  limit?: number;
  /*
   * OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
   *
   * @minimum 0
   */
  offset?: number;
  /*
   * Sort by one of the listed field names. If the field name is prefixed with `-`, it will sort in descending order.
   */
  sort?: string;
  /*
   * Include variables the user has no measurements for
   */
  includePublic?: boolean;
  /*
   * Only include variables tracked manually by the user
   */
  manualTracking?: boolean;
  /*
   * Your CureDAO client id can be obtained by creating an app at https://builder.curedao.org
   */
  clientId?: string;
  /*
   * UPC or other barcode scan result
   */
  upc?: string;
  /*
   * Provided variable is the effect or cause
   */
  effectOrCause?: string;
  /*
   * Ex:
   */
  publicEffectOrCause?: string;
  /*
   * Require exact match
   */
  exactMatch?: boolean;
  /*
   * Ex: 13
   */
  variableCategoryId?: number;
  /*
   * Include user-specific variables in results
   */
  includePrivate?: boolean;
  /*
   * Ex: %Body Fat%
   */
  searchPhrase?: string;
  /*
   * Ex: McDonalds hotcake
   */
  synonyms?: string;
  /*
   * Id of the tagged variable (i.e. Lollipop) you would like to get variables it can be tagged with (i.e. Sugar).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
   */
  taggedVariableId?: number;
  /*
   * Id of the tag variable (i.e. Sugar) you would like to get variables it can be tagged to (i.e. Lollipop).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
   */
  tagVariableId?: number;
  /*
   * Id of the variable you would like to get variables that can be joined to.  This is used to merge duplicate variables.   If joinVariableId is specified, this returns only variables eligible to be joined to the variable specified by the joinVariableId.
   */
  joinVariableId?: number;
  /*
   * Id of the parent category variable (i.e. Fruit) you would like to get eligible child sub-type variables (i.e. Apple) for.  Child variable measurements will be included in analysis of the parent variable.  For instance, a child sub-type of the parent category Fruit could be Apple.  When Apple is tagged with the parent category Fruit, Apple measurements will be included when Fruit is analyzed.
   */
  parentUserTagVariableId?: number;
  /*
   * Id of the child sub-type variable (i.e. Apple) you would like to get eligible parent variables (i.e. Fruit) for.  Child variable measurements will be included in analysis of the parent variable.  For instance, a child sub-type of the parent category Fruit could be Apple. When Apple is tagged with the parent category Fruit, Apple measurements will be included when Fruit is analyzed.
   */
  childUserTagVariableId?: number;
  /*
   * Id of the ingredient variable (i.e. Fructose)  you would like to get eligible ingredientOf variables (i.e. Apple) for.  IngredientOf variable measurements will be included in analysis of the ingredient variable.  For instance, a ingredientOf of variable Fruit could be Apple.
   */
  ingredientUserTagVariableId?: number;
  /*
   * Id of the ingredientOf variable (i.e. Apple) you would like to get eligible ingredient variables (i.e. Fructose) for.  IngredientOf variable measurements will be included in analysis of the ingredient variable.  For instance, a ingredientOf of variable Fruit could be Apple.
   */
  ingredientOfUserTagVariableId?: number;
  /*
   * Return only public and aggregated common variable data instead of user-specific variables
   */
  commonOnly?: boolean;
  /*
   * Return only user-specific variables and data, excluding common aggregated variable data
   */
  userOnly?: boolean;
  /*
   * Return parent, child, duplicate, and ingredient variables
   */
  includeTags?: boolean;
  /*
   * Recalculate instead of using cached analysis
   */
  recalculate?: boolean;
  /*
   * Ex: 13
   */
  variableId?: number;
  /*
   * Only return field required for variable auto-complete searches.  The smaller size allows for storing more variable results locally reducing API requests.
   */
  concise?: boolean;
  /*
   * Regenerate charts instead of getting from the cache
   */
  refresh?: boolean;
};

export type GetVariablesError = Fetcher.ErrorWrapper<undefined>;

export type GetVariablesResponse = Schemas.Variable[];

export type GetVariablesVariables = {
  queryParams?: GetVariablesQueryParams;
} & CuredaoContext["fetcherOptions"];

/**
 * Get variables. If the user has specified variable settings, these are provided instead of the common variable defaults.
 */
export const fetchGetVariables = (variables: GetVariablesVariables) =>
  curedaoFetch<
    GetVariablesResponse,
    GetVariablesError,
    undefined,
    {},
    GetVariablesQueryParams,
    {}
  >({ url: "/v3/variables", method: "get", ...variables });

/**
 * Get variables. If the user has specified variable settings, these are provided instead of the common variable defaults.
 */
export const useGetVariables = (
  variables: GetVariablesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetVariablesResponse,
      GetVariablesError,
      GetVariablesResponse
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useCuredaoContext(options);
  return reactQuery.useQuery<
    GetVariablesResponse,
    GetVariablesError,
    GetVariablesResponse
  >(
    queryKeyFn({
      path: "/v3/variables",
      operationId: "getVariables",
      variables,
    }),
    () => fetchGetVariables({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type PostUserVariablesQueryParams = {
  /*
   * Include user-specific variables in results
   */
  includePrivate?: boolean;
  /*
   * Your CureDAO client id can be obtained by creating an app at https://builder.curedao.org
   */
  clientId?: string;
  /*
   * Include variables the user has no measurements for
   */
  includePublic?: boolean;
  /*
   * Ex: %Body Fat%
   */
  searchPhrase?: string;
  /*
   * Require exact match
   */
  exactMatch?: boolean;
  /*
   * Only include variables tracked manually by the user
   */
  manualTracking?: boolean;
  /*
   * Ex: Emotions, Treatments, Symptoms...
   */
  variableCategoryName?:
    | "Activities"
    | "Books"
    | "Causes of Illness"
    | "Cognitive Performance"
    | "Conditions"
    | "Emotions"
    | "Environment"
    | "Foods"
    | "Location"
    | "Miscellaneous"
    | "Movies and TV"
    | "Music"
    | "Nutrients"
    | "Payments"
    | "Physical Activity"
    | "Physique"
    | "Sleep"
    | "Social Interactions"
    | "Software"
    | "Symptoms"
    | "Treatments"
    | "Vital Signs"
    | "Goals";
  /*
   * Ex: 13
   */
  variableCategoryId?: number;
  /*
   * Ex: McDonalds hotcake
   */
  synonyms?: string;
};

export type PostUserVariablesError = Fetcher.ErrorWrapper<undefined>;

export type PostUserVariablesVariables = {
  body?: RequestBodies.UserVariablesParam;
  queryParams?: PostUserVariablesQueryParams;
} & CuredaoContext["fetcherOptions"];

/**
 * Users can change the parameters used in analysis of that variable such as the expected duration of action for a variable to have an effect, the estimated delay before the onset of action. In order to filter out erroneous data, they are able to set the maximum and minimum reasonable daily values for a variable.
 */
export const fetchPostUserVariables = (variables: PostUserVariablesVariables) =>
  curedaoFetch<
    Schemas.CommonResponse,
    PostUserVariablesError,
    RequestBodies.UserVariablesParam,
    {},
    PostUserVariablesQueryParams,
    {}
  >({ url: "/v3/variables", method: "post", ...variables });

/**
 * Users can change the parameters used in analysis of that variable such as the expected duration of action for a variable to have an effect, the estimated delay before the onset of action. In order to filter out erroneous data, they are able to set the maximum and minimum reasonable daily values for a variable.
 */
export const usePostUserVariables = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CommonResponse,
      PostUserVariablesError,
      PostUserVariablesVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useCuredaoContext();
  return reactQuery.useMutation<
    Schemas.CommonResponse,
    PostUserVariablesError,
    PostUserVariablesVariables
  >(
    (variables: PostUserVariablesVariables) =>
      fetchPostUserVariables({ ...fetcherOptions, ...variables }),
    options
  );
};

export type GetMeasurementsQueryParams = {
  /*
   * Name of the variable you want measurements for
   */
  variableName?: string;
  /*
   * Sort by one of the listed field names. If the field name is prefixed with `-`, it will sort in descending order.
   */
  sort?: string;
  /*
   * The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
   *
   * @default 100
   */
  limit?: number;
  /*
   * OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
   *
   * @minimum 0
   */
  offset?: number;
  /*
   * Ex: Emotions, Treatments, Symptoms...
   */
  variableCategoryName?:
    | "Activities"
    | "Books"
    | "Causes of Illness"
    | "Cognitive Performance"
    | "Conditions"
    | "Emotions"
    | "Environment"
    | "Foods"
    | "Location"
    | "Miscellaneous"
    | "Movies and TV"
    | "Music"
    | "Nutrients"
    | "Payments"
    | "Physical Activity"
    | "Physique"
    | "Sleep"
    | "Social Interactions"
    | "Software"
    | "Symptoms"
    | "Treatments"
    | "Vital Signs"
    | "Goals";
  /*
   * When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
   */
  updatedAt?: string;
  /*
   * User's id
   */
  userId?: number;
  /*
   * ID of the source you want measurements for (supports exact name match only)
   */
  sourceName?: string;
  /*
   * Ex: facebook
   */
  connectorName?: string;
  /*
   * Value of measurement
   */
  value?: string;
  /*
   * Ex: Milligrams
   */
  unitName?:
    | "% Recommended Daily Allowance"
    | "-4 to 4 Rating"
    | "0 to 1 Rating"
    | "0 to 5 Rating"
    | "1 to 10 Rating"
    | "1 to 5 Rating"
    | "Applications"
    | "Beats per Minute"
    | "Calories"
    | "Capsules"
    | "Centimeters"
    | "Count"
    | "Degrees Celsius"
    | "Degrees East"
    | "Degrees Fahrenheit"
    | "Degrees North"
    | "Dollars"
    | "Drops"
    | "Event"
    | "Feet"
    | "Grams"
    | "Hours"
    | "Inches"
    | "Index"
    | "Kilocalories"
    | "Kilograms"
    | "Kilometers"
    | "Liters"
    | "Meters"
    | "Micrograms"
    | "Micrograms per decilitre"
    | "Miles"
    | "Milligrams"
    | "Milliliters"
    | "Millimeters"
    | "Millimeters Merc"
    | "Milliseconds"
    | "Minutes"
    | "Pascal"
    | "Percent"
    | "Pieces"
    | "Pills"
    | "Pounds"
    | "Puffs"
    | "Seconds"
    | "Serving"
    | "Sprays"
    | "Tablets"
    | "Torr"
    | "Units"
    | "Yes/No"
    | "per Minute"
    | "Doses"
    | "Quarts"
    | "Ounces"
    | "International Units"
    | "Meters per Second";
  /*
   * Excluded records with measurement times earlier than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
   */
  earliestMeasurementTime?: string;
  /*
   * Excluded records with measurement times later than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
   */
  latestMeasurementTime?: string;
  /*
   * When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
   */
  createdAt?: string;
  /*
   * Measurement id
   */
  id?: number;
  /*
   * The time (in seconds) over which measurements are grouped together
   */
  groupingWidth?: number;
  /*
   * The time (in seconds) over which measurements are grouped together
   */
  groupingTimezone?: string;
  /*
   * Ex: true
   */
  doNotProcess?: boolean;
  /*
   * Your CureDAO client id can be obtained by creating an app at https://builder.curedao.org
   */
  clientId?: string;
  /*
   * Ex: 1
   */
  doNotConvert?: boolean;
  /*
   * Ex: 1
   */
  minMaxFilter?: boolean;
};

export type GetMeasurementsError = Fetcher.ErrorWrapper<undefined>;

export type GetMeasurementsResponse = Schemas.Measurement[];

export type GetMeasurementsVariables = {
  queryParams?: GetMeasurementsQueryParams;
} & CuredaoContext["fetcherOptions"];

/**
 * Measurements are any value that can be recorded like daily steps, a mood rating, or apples eaten.
 */
export const fetchGetMeasurements = (variables: GetMeasurementsVariables) =>
  curedaoFetch<
    GetMeasurementsResponse,
    GetMeasurementsError,
    undefined,
    {},
    GetMeasurementsQueryParams,
    {}
  >({ url: "/v3/measurements", method: "get", ...variables });

/**
 * Measurements are any value that can be recorded like daily steps, a mood rating, or apples eaten.
 */
export const useGetMeasurements = (
  variables: GetMeasurementsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetMeasurementsResponse,
      GetMeasurementsError,
      GetMeasurementsResponse
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useCuredaoContext(options);
  return reactQuery.useQuery<
    GetMeasurementsResponse,
    GetMeasurementsError,
    GetMeasurementsResponse
  >(
    queryKeyFn({
      path: "/v3/measurements",
      operationId: "getMeasurements",
      variables,
    }),
    () => fetchGetMeasurements({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type PostMeasurementsQueryParams = {
  /*
   * User's id
   */
  userId?: number;
};

export type PostMeasurementsError = Fetcher.ErrorWrapper<undefined>;

export type PostMeasurementsRequestBody = Schemas.MeasurementSet[];

export type PostMeasurementsVariables = {
  body?: PostMeasurementsRequestBody;
  queryParams?: PostMeasurementsQueryParams;
} & CuredaoContext["fetcherOptions"];

/**
 * You can submit or update multiple measurements in a "measurements" sub-array.  If the variable these measurements correspond to does not already exist in the database, it will be automatically added.
 */
export const fetchPostMeasurements = (variables: PostMeasurementsVariables) =>
  curedaoFetch<
    Schemas.PostMeasurementsResponse,
    PostMeasurementsError,
    PostMeasurementsRequestBody,
    {},
    PostMeasurementsQueryParams,
    {}
  >({ url: "/v3/measurements/post", method: "post", ...variables });

/**
 * You can submit or update multiple measurements in a "measurements" sub-array.  If the variable these measurements correspond to does not already exist in the database, it will be automatically added.
 */
export const usePostMeasurements = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.PostMeasurementsResponse,
      PostMeasurementsError,
      PostMeasurementsVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useCuredaoContext();
  return reactQuery.useMutation<
    Schemas.PostMeasurementsResponse,
    PostMeasurementsError,
    PostMeasurementsVariables
  >(
    (variables: PostMeasurementsVariables) =>
      fetchPostMeasurements({ ...fetcherOptions, ...variables }),
    options
  );
};

export type UpdateMeasurementError = Fetcher.ErrorWrapper<undefined>;

export type UpdateMeasurementVariables = {
  body: Schemas.MeasurementUpdate;
} & CuredaoContext["fetcherOptions"];

/**
 * Update a previously submitted measurement
 */
export const fetchUpdateMeasurement = (variables: UpdateMeasurementVariables) =>
  curedaoFetch<
    Schemas.CommonResponse,
    UpdateMeasurementError,
    Schemas.MeasurementUpdate,
    {},
    {},
    {}
  >({ url: "/v3/measurements/update", method: "post", ...variables });

/**
 * Update a previously submitted measurement
 */
export const useUpdateMeasurement = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CommonResponse,
      UpdateMeasurementError,
      UpdateMeasurementVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useCuredaoContext();
  return reactQuery.useMutation<
    Schemas.CommonResponse,
    UpdateMeasurementError,
    UpdateMeasurementVariables
  >(
    (variables: UpdateMeasurementVariables) =>
      fetchUpdateMeasurement({ ...fetcherOptions, ...variables }),
    options
  );
};

export type DeleteMeasurementError = Fetcher.ErrorWrapper<undefined>;

export type DeleteMeasurementVariables = CuredaoContext["fetcherOptions"];

/**
 * Delete a previously submitted measurement
 */
export const fetchDeleteMeasurement = (variables: DeleteMeasurementVariables) =>
  curedaoFetch<
    Schemas.CommonResponse,
    DeleteMeasurementError,
    undefined,
    {},
    {},
    {}
  >({ url: "/v3/measurements/delete", method: "delete", ...variables });

/**
 * Delete a previously submitted measurement
 */
export const useDeleteMeasurement = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CommonResponse,
      DeleteMeasurementError,
      DeleteMeasurementVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useCuredaoContext();
  return reactQuery.useMutation<
    Schemas.CommonResponse,
    DeleteMeasurementError,
    DeleteMeasurementVariables
  >(
    (variables: DeleteMeasurementVariables) =>
      fetchDeleteMeasurement({ ...fetcherOptions, ...variables }),
    options
  );
};

export type GetAppSettingsQueryParams = {
  /*
   * Your CureDAO client id can be obtained by creating an app at https://builder.curedao.org
   */
  clientId?: string;
  /*
   * This is the secret for your obtained clientId. We use this to ensure that only your application uses the clientId.  Obtain this by creating a free application at [https://builder.curedao.org](https://builder.curedao.org).
   */
  client_secret?: string;
};

export type GetAppSettingsError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Schemas.JsonErrorResponse;
}>;

export type GetAppSettingsVariables = {
  queryParams?: GetAppSettingsQueryParams;
} & CuredaoContext["fetcherOptions"];

/**
 * Get the settings for your application configurable at https://builder.curedao.org
 */
export const fetchGetAppSettings = (variables: GetAppSettingsVariables) =>
  curedaoFetch<
    Schemas.AppSettingsResponse,
    GetAppSettingsError,
    undefined,
    {},
    GetAppSettingsQueryParams,
    {}
  >({ url: "/v3/appSettings", method: "get", ...variables });

/**
 * Get the settings for your application configurable at https://builder.curedao.org
 */
export const useGetAppSettings = (
  variables: GetAppSettingsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.AppSettingsResponse,
      GetAppSettingsError,
      Schemas.AppSettingsResponse
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useCuredaoContext(options);
  return reactQuery.useQuery<
    Schemas.AppSettingsResponse,
    GetAppSettingsError,
    Schemas.AppSettingsResponse
  >(
    queryKeyFn({
      path: "/v3/appSettings",
      operationId: "getAppSettings",
      variables,
    }),
    () => fetchGetAppSettings({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type MeasurementExportRequestQueryParams = {
  /*
   * User's id
   */
  userId?: number;
};

export type MeasurementExportRequestError = Fetcher.ErrorWrapper<undefined>;

export type MeasurementExportRequestVariables = {
  queryParams?: MeasurementExportRequestQueryParams;
} & CuredaoContext["fetcherOptions"];

/**
 * Use this endpoint to schedule a CSV export containing all user measurements to be emailed to the user within 24 hours.
 */
export const fetchMeasurementExportRequest = (
  variables: MeasurementExportRequestVariables
) =>
  curedaoFetch<
    number,
    MeasurementExportRequestError,
    undefined,
    {},
    MeasurementExportRequestQueryParams,
    {}
  >({ url: "/v2/measurements/exportRequest", method: "post", ...variables });

/**
 * Use this endpoint to schedule a CSV export containing all user measurements to be emailed to the user within 24 hours.
 */
export const useMeasurementExportRequest = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      number,
      MeasurementExportRequestError,
      MeasurementExportRequestVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useCuredaoContext();
  return reactQuery.useMutation<
    number,
    MeasurementExportRequestError,
    MeasurementExportRequestVariables
  >(
    (variables: MeasurementExportRequestVariables) =>
      fetchMeasurementExportRequest({ ...fetcherOptions, ...variables }),
    options
  );
};

export type GetMobileConnectPageQueryParams = {
  /*
   * User's id
   */
  userId?: number;
};

export type GetMobileConnectPageError = Fetcher.ErrorWrapper<undefined>;

export type GetMobileConnectPageVariables = {
  queryParams?: GetMobileConnectPageQueryParams;
} & CuredaoContext["fetcherOptions"];

/**
 * This page is designed to be opened in a webview.  Instead of using popup authentication boxes, it uses redirection. You can include the user's access_token as a URL parameter like https://api.curedao.org/api/v3/connect/mobile?access_token=123
 */
export const fetchGetMobileConnectPage = (
  variables: GetMobileConnectPageVariables
) =>
  curedaoFetch<
    undefined,
    GetMobileConnectPageError,
    undefined,
    {},
    GetMobileConnectPageQueryParams,
    {}
  >({ url: "/v3/connect/mobile", method: "get", ...variables });

/**
 * This page is designed to be opened in a webview.  Instead of using popup authentication boxes, it uses redirection. You can include the user's access_token as a URL parameter like https://api.curedao.org/api/v3/connect/mobile?access_token=123
 */
export const useGetMobileConnectPage = (
  variables: GetMobileConnectPageVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetMobileConnectPageError, undefined>,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useCuredaoContext(options);
  return reactQuery.useQuery<undefined, GetMobileConnectPageError, undefined>(
    queryKeyFn({
      path: "/v3/connect/mobile",
      operationId: "getMobileConnectPage",
      variables,
    }),
    () => fetchGetMobileConnectPage({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type GetConnectorsQueryParams = {
  /*
   * Your CureDAO client id can be obtained by creating an app at https://builder.curedao.org
   */
  clientId?: string;
};

export type GetConnectorsError = Fetcher.ErrorWrapper<undefined>;

export type GetConnectorsVariables = {
  queryParams?: GetConnectorsQueryParams;
} & CuredaoContext["fetcherOptions"];

/**
 * A connector pulls data from other data providers using their API or a screenscraper. Returns a list of all available connectors and information about them such as their id, name, whether the user has provided access, logo url, connection instructions, and the update history.
 */
export const fetchGetConnectors = (variables: GetConnectorsVariables) =>
  curedaoFetch<
    Schemas.GetConnectorsResponse,
    GetConnectorsError,
    undefined,
    {},
    GetConnectorsQueryParams,
    {}
  >({ url: "/v3/connectors/list", method: "get", ...variables });

/**
 * A connector pulls data from other data providers using their API or a screenscraper. Returns a list of all available connectors and information about them such as their id, name, whether the user has provided access, logo url, connection instructions, and the update history.
 */
export const useGetConnectors = (
  variables: GetConnectorsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.GetConnectorsResponse,
      GetConnectorsError,
      Schemas.GetConnectorsResponse
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useCuredaoContext(options);
  return reactQuery.useQuery<
    Schemas.GetConnectorsResponse,
    GetConnectorsError,
    Schemas.GetConnectorsResponse
  >(
    queryKeyFn({
      path: "/v3/connectors/list",
      operationId: "getConnectors",
      variables,
    }),
    () => fetchGetConnectors({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type ConnectConnectorPathParams = {
  /*
   * Lowercase system name of the source application or device. Get a list of available connectors from the /v3/connectors/list endpoint.
   */
  connectorName:
    | "facebook"
    | "fitbit"
    | "github"
    | "googlecalendar"
    | "googlefit"
    | "medhelper"
    | "mint"
    | "moodpanda"
    | "moodscope"
    | "myfitnesspal"
    | "mynetdiary"
    | "netatmo"
    | "rescuetime"
    | "runkeeper"
    | "slack"
    | "sleepcloud"
    | "slice"
    | "up"
    | "whatpulse"
    | "withings"
    | "worldweatheronline"
    | "foursquare"
    | "strava"
    | "gmail";
};

export type ConnectConnectorQueryParams = {
  /*
   * User's id
   */
  userId?: number;
};

export type ConnectConnectorError = Fetcher.ErrorWrapper<undefined>;

export type ConnectConnectorVariables = {
  pathParams: ConnectConnectorPathParams;
  queryParams?: ConnectConnectorQueryParams;
} & CuredaoContext["fetcherOptions"];

/**
 * Attempt to obtain a token from the data provider, store it in the database. With this, the connector to continue to obtain new user data until the token is revoked.
 */
export const fetchConnectConnector = (variables: ConnectConnectorVariables) =>
  curedaoFetch<
    undefined,
    ConnectConnectorError,
    undefined,
    {},
    ConnectConnectorQueryParams,
    ConnectConnectorPathParams
  >({
    url: "/v3/connectors/{connectorName}/connect",
    method: "get",
    ...variables,
  });

/**
 * Attempt to obtain a token from the data provider, store it in the database. With this, the connector to continue to obtain new user data until the token is revoked.
 */
export const useConnectConnector = (
  variables: ConnectConnectorVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, ConnectConnectorError, undefined>,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useCuredaoContext(options);
  return reactQuery.useQuery<undefined, ConnectConnectorError, undefined>(
    queryKeyFn({
      path: "/v3/connectors/{connectorName}/connect",
      operationId: "connectConnector",
      variables,
    }),
    () => fetchConnectConnector({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type DisconnectConnectorPathParams = {
  /*
   * Lowercase system name of the source application or device. Get a list of available connectors from the /v3/connectors/list endpoint.
   */
  connectorName:
    | "facebook"
    | "fitbit"
    | "github"
    | "googlecalendar"
    | "googlefit"
    | "medhelper"
    | "mint"
    | "moodpanda"
    | "moodscope"
    | "myfitnesspal"
    | "mynetdiary"
    | "netatmo"
    | "rescuetime"
    | "runkeeper"
    | "slack"
    | "sleepcloud"
    | "slice"
    | "up"
    | "whatpulse"
    | "withings"
    | "worldweatheronline"
    | "foursquare"
    | "strava"
    | "gmail";
};

export type DisconnectConnectorError = Fetcher.ErrorWrapper<undefined>;

export type DisconnectConnectorVariables = {
  pathParams: DisconnectConnectorPathParams;
} & CuredaoContext["fetcherOptions"];

/**
 * The disconnect method deletes any stored tokens or connection information from the connectors database.
 */
export const fetchDisconnectConnector = (
  variables: DisconnectConnectorVariables
) =>
  curedaoFetch<
    undefined,
    DisconnectConnectorError,
    undefined,
    {},
    {},
    DisconnectConnectorPathParams
  >({
    url: "/v3/connectors/{connectorName}/disconnect",
    method: "get",
    ...variables,
  });

/**
 * The disconnect method deletes any stored tokens or connection information from the connectors database.
 */
export const useDisconnectConnector = (
  variables: DisconnectConnectorVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, DisconnectConnectorError, undefined>,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useCuredaoContext(options);
  return reactQuery.useQuery<undefined, DisconnectConnectorError, undefined>(
    queryKeyFn({
      path: "/v3/connectors/{connectorName}/disconnect",
      operationId: "disconnectConnector",
      variables,
    }),
    () => fetchDisconnectConnector({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type UpdateConnectorPathParams = {
  /*
   * Lowercase system name of the source application or device. Get a list of available connectors from the /v3/connectors/list endpoint.
   */
  connectorName:
    | "facebook"
    | "fitbit"
    | "github"
    | "googlecalendar"
    | "googlefit"
    | "medhelper"
    | "mint"
    | "moodpanda"
    | "moodscope"
    | "myfitnesspal"
    | "mynetdiary"
    | "netatmo"
    | "rescuetime"
    | "runkeeper"
    | "slack"
    | "sleepcloud"
    | "slice"
    | "up"
    | "whatpulse"
    | "withings"
    | "worldweatheronline"
    | "foursquare"
    | "strava"
    | "gmail";
};

export type UpdateConnectorQueryParams = {
  /*
   * User's id
   */
  userId?: number;
};

export type UpdateConnectorError = Fetcher.ErrorWrapper<undefined>;

export type UpdateConnectorVariables = {
  pathParams: UpdateConnectorPathParams;
  queryParams?: UpdateConnectorQueryParams;
} & CuredaoContext["fetcherOptions"];

/**
 * The update method tells the QM Connector Framework to check with the data provider (such as Fitbit or MyFitnessPal) and retrieve any new measurements available.
 */
export const fetchUpdateConnector = (variables: UpdateConnectorVariables) =>
  curedaoFetch<
    undefined,
    UpdateConnectorError,
    undefined,
    {},
    UpdateConnectorQueryParams,
    UpdateConnectorPathParams
  >({
    url: "/v3/connectors/{connectorName}/update",
    method: "get",
    ...variables,
  });

/**
 * The update method tells the QM Connector Framework to check with the data provider (such as Fitbit or MyFitnessPal) and retrieve any new measurements available.
 */
export const useUpdateConnector = (
  variables: UpdateConnectorVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, UpdateConnectorError, undefined>,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useCuredaoContext(options);
  return reactQuery.useQuery<undefined, UpdateConnectorError, undefined>(
    queryKeyFn({
      path: "/v3/connectors/{connectorName}/update",
      operationId: "updateConnector",
      variables,
    }),
    () => fetchUpdateConnector({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type GetCorrelationsQueryParams = {
  /*
   * Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
   */
  causeVariableName?: string;
  /*
   * Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
   */
  effectVariableName?: string;
  /*
   * Sort by one of the listed field names. If the field name is prefixed with `-`, it will sort in descending order.
   */
  sort?: string;
  /*
   * The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
   *
   * @default 100
   */
  limit?: number;
  /*
   * OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
   *
   * @minimum 0
   */
  offset?: number;
  /*
   * User's id
   */
  userId?: number;
  /*
   * Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action
   */
  correlationCoefficient?: string;
  /*
   * When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
   */
  updatedAt?: string;
  /*
   * Only include correlations for which the effect is an outcome of interest for the user
   */
  outcomesOfInterest?: boolean;
  /*
   * Your CureDAO client id can be obtained by creating an app at https://builder.curedao.org
   */
  clientId?: string;
  /*
   * Return only public, anonymized and aggregated population data instead of user-specific variables
   */
  commonOnly?: boolean;
};

export type GetCorrelationsError = Fetcher.ErrorWrapper<undefined>;

export type GetCorrelationsVariables = {
  queryParams?: GetCorrelationsQueryParams;
} & CuredaoContext["fetcherOptions"];

/**
 * Get a list of correlations that can be used to display top predictors of a given outcome like mood, for instance.
 */
export const fetchGetCorrelations = (variables: GetCorrelationsVariables) =>
  curedaoFetch<
    Schemas.GetCorrelationsResponse,
    GetCorrelationsError,
    undefined,
    {},
    GetCorrelationsQueryParams,
    {}
  >({ url: "/v3/correlations", method: "get", ...variables });

/**
 * Get a list of correlations that can be used to display top predictors of a given outcome like mood, for instance.
 */
export const useGetCorrelations = (
  variables: GetCorrelationsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.GetCorrelationsResponse,
      GetCorrelationsError,
      Schemas.GetCorrelationsResponse
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useCuredaoContext(options);
  return reactQuery.useQuery<
    Schemas.GetCorrelationsResponse,
    GetCorrelationsError,
    Schemas.GetCorrelationsResponse
  >(
    queryKeyFn({
      path: "/v3/correlations",
      operationId: "getCorrelations",
      variables,
    }),
    () => fetchGetCorrelations({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type PostDeviceTokenError = Fetcher.ErrorWrapper<undefined>;

export type PostDeviceTokenVariables = {
  body: Schemas.DeviceToken;
} & CuredaoContext["fetcherOptions"];

/**
 * Post user token for Android, iOS, or web push notifications
 */
export const fetchPostDeviceToken = (variables: PostDeviceTokenVariables) =>
  curedaoFetch<
    undefined,
    PostDeviceTokenError,
    Schemas.DeviceToken,
    {},
    {},
    {}
  >({ url: "/v3/deviceTokens", method: "post", ...variables });

/**
 * Post user token for Android, iOS, or web push notifications
 */
export const usePostDeviceToken = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostDeviceTokenError,
      PostDeviceTokenVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useCuredaoContext();
  return reactQuery.useMutation<
    undefined,
    PostDeviceTokenError,
    PostDeviceTokenVariables
  >(
    (variables: PostDeviceTokenVariables) =>
      fetchPostDeviceToken({ ...fetcherOptions, ...variables }),
    options
  );
};

export type GetFeedQueryParams = {
  /*
   * Sort by one of the listed field names. If the field name is prefixed with `-`, it will sort in descending order.
   */
  sort?: string;
  /*
   * User's id
   */
  userId?: number;
  /*
   * When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
   */
  createdAt?: string;
  /*
   * When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
   */
  updatedAt?: string;
  /*
   * The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
   *
   * @default 100
   */
  limit?: number;
  /*
   * OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
   *
   * @minimum 0
   */
  offset?: number;
  /*
   * Your CureDAO client id can be obtained by creating an app at https://builder.curedao.org
   */
  clientId?: string;
};

export type GetFeedError = Fetcher.ErrorWrapper<undefined>;

export type GetFeedVariables = {
  queryParams?: GetFeedQueryParams;
} & CuredaoContext["fetcherOptions"];

/**
 * Tracking reminder notifications, messages, and study results
 */
export const fetchGetFeed = (variables: GetFeedVariables) =>
  curedaoFetch<
    Schemas.FeedResponse,
    GetFeedError,
    undefined,
    {},
    GetFeedQueryParams,
    {}
  >({ url: "/v3/feed", method: "get", ...variables });

/**
 * Tracking reminder notifications, messages, and study results
 */
export const useGetFeed = (
  variables: GetFeedVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.FeedResponse,
      GetFeedError,
      Schemas.FeedResponse
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useCuredaoContext(options);
  return reactQuery.useQuery<
    Schemas.FeedResponse,
    GetFeedError,
    Schemas.FeedResponse
  >(
    queryKeyFn({ path: "/v3/feed", operationId: "getFeed", variables }),
    () => fetchGetFeed({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type PostFeedQueryParams = {
  /*
   * User's id
   */
  userId?: number;
  /*
   * Your CureDAO client id can be obtained by creating an app at https://builder.curedao.org
   */
  clientId?: string;
};

export type PostFeedError = Fetcher.ErrorWrapper<undefined>;

export type PostFeedRequestBody = Schemas.Card[];

export type PostFeedVariables = {
  body?: PostFeedRequestBody;
  queryParams?: PostFeedQueryParams;
} & CuredaoContext["fetcherOptions"];

/**
 * Post user actions on feed cards
 */
export const fetchPostFeed = (variables: PostFeedVariables) =>
  curedaoFetch<
    Schemas.FeedResponse,
    PostFeedError,
    PostFeedRequestBody,
    {},
    PostFeedQueryParams,
    {}
  >({ url: "/v3/feed", method: "post", ...variables });

/**
 * Post user actions on feed cards
 */
export const usePostFeed = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.FeedResponse,
      PostFeedError,
      PostFeedVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useCuredaoContext();
  return reactQuery.useMutation<
    Schemas.FeedResponse,
    PostFeedError,
    PostFeedVariables
  >(
    (variables: PostFeedVariables) =>
      fetchPostFeed({ ...fetcherOptions, ...variables }),
    options
  );
};

export type GetIntegrationJsQueryParams = {
  /*
   * Your CureDAO client id can be obtained by creating an app at https://builder.curedao.org
   */
  clientId?: string;
};

export type GetIntegrationJsError = Fetcher.ErrorWrapper<undefined>;

export type GetIntegrationJsVariables = {
  queryParams?: GetIntegrationJsQueryParams;
} & CuredaoContext["fetcherOptions"];

/**
 * Get embeddable connect javascript. Usage:
 *   - Embedding in applications with popups for 3rd-party authentication
 * windows.
 *     Use `qmSetupInPopup` function after connecting `connect.js`.
 *   - Embedding in applications with popups for 3rd-party authentication
 * windows.
 *     Requires a selector to block. It will be embedded in this block.
 *     Use `qmSetupOnPage` function after connecting `connect.js`.
 *   - Embedding in mobile applications without popups for 3rd-party
 * authentication.
 *     Use `qmSetupOnMobile` function after connecting `connect.js`.
 *     If using in a Cordova application call  `qmSetupOnIonic` function after connecting `connect.js`.
 */
export const fetchGetIntegrationJs = (variables: GetIntegrationJsVariables) =>
  curedaoFetch<
    undefined,
    GetIntegrationJsError,
    undefined,
    {},
    GetIntegrationJsQueryParams,
    {}
  >({ url: "/v3/integration.js", method: "get", ...variables });

/**
 * Get embeddable connect javascript. Usage:
 *   - Embedding in applications with popups for 3rd-party authentication
 * windows.
 *     Use `qmSetupInPopup` function after connecting `connect.js`.
 *   - Embedding in applications with popups for 3rd-party authentication
 * windows.
 *     Requires a selector to block. It will be embedded in this block.
 *     Use `qmSetupOnPage` function after connecting `connect.js`.
 *   - Embedding in mobile applications without popups for 3rd-party
 * authentication.
 *     Use `qmSetupOnMobile` function after connecting `connect.js`.
 *     If using in a Cordova application call  `qmSetupOnIonic` function after connecting `connect.js`.
 */
export const useGetIntegrationJs = (
  variables: GetIntegrationJsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetIntegrationJsError, undefined>,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useCuredaoContext(options);
  return reactQuery.useQuery<undefined, GetIntegrationJsError, undefined>(
    queryKeyFn({
      path: "/v3/integration.js",
      operationId: "getIntegrationJs",
      variables,
    }),
    () => fetchGetIntegrationJs({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type GetNotificationPreferencesError = Fetcher.ErrorWrapper<undefined>;

export type GetNotificationPreferencesVariables =
  CuredaoContext["fetcherOptions"];

/**
 * Get NotificationPreferences
 */
export const fetchGetNotificationPreferences = (
  variables: GetNotificationPreferencesVariables
) =>
  curedaoFetch<
    undefined,
    GetNotificationPreferencesError,
    undefined,
    {},
    {},
    {}
  >({ url: "/v3/notificationPreferences", method: "get", ...variables });

/**
 * Get NotificationPreferences
 */
export const useGetNotificationPreferences = (
  variables: GetNotificationPreferencesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      GetNotificationPreferencesError,
      undefined
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useCuredaoContext(options);
  return reactQuery.useQuery<
    undefined,
    GetNotificationPreferencesError,
    undefined
  >(
    queryKeyFn({
      path: "/v3/notificationPreferences",
      operationId: "getNotificationPreferences",
      variables,
    }),
    () => fetchGetNotificationPreferences({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type GetOauthAuthorizationCodeQueryParams = {
  /*
   * Your CureDAO client id can be obtained by creating an app at https://builder.curedao.org
   */
  clientId?: string;
  /*
   * This is the secret for your obtained clientId. We use this to ensure that only your application uses the clientId.  Obtain this by creating a free application at [https://builder.curedao.org](https://builder.curedao.org).
   */
  client_secret?: string;
  /*
   * If the value is code, launches a Basic flow, requiring a POST to the token endpoint to obtain the tokens. If the value is token id_token or id_token token, launches an Implicit flow, requiring the use of Javascript at the redirect URI to retrieve tokens from the URI #fragment.
   */
  response_type: string;
  /*
   * Scopes include basic, readmeasurements, and writemeasurements. The `basic` scope allows you to read user info (displayName, email, etc). The `readmeasurements` scope allows one to read a user's data. The `writemeasurements` scope allows you to write user data. Separate multiple scopes by a space.
   */
  scope: string;
  /*
   * The redirect URI is the URL within your client application that will receive the OAuth2 credentials.
   */
  redirect_uri?: string;
  /*
   * An opaque string that is round-tripped in the protocol; that is to say, it is returned as a URI parameter in the Basic flow, and in the URI
   */
  state?: string;
};

export type GetOauthAuthorizationCodeError = Fetcher.ErrorWrapper<undefined>;

export type GetOauthAuthorizationCodeVariables = {
  queryParams: GetOauthAuthorizationCodeQueryParams;
} & CuredaoContext["fetcherOptions"];

/**
 * You can implement OAuth2 authentication to your application using our **OAuth2** endpoints.  You need to redirect users to `/api/v3/oauth2/authorize` endpoint to get an authorization code and include the parameters below.   This page will ask the user if they want to allow a client's application to submit or obtain data from their QM account. It will redirect the user to the url provided by the client application with the code as a query parameter or error in case of an error. See the /api/v1/oauth/access_token endpoint for the next steps.
 */
export const fetchGetOauthAuthorizationCode = (
  variables: GetOauthAuthorizationCodeVariables
) =>
  curedaoFetch<
    undefined,
    GetOauthAuthorizationCodeError,
    undefined,
    {},
    GetOauthAuthorizationCodeQueryParams,
    {}
  >({ url: "/v3/oauth2/authorize", method: "get", ...variables });

/**
 * You can implement OAuth2 authentication to your application using our **OAuth2** endpoints.  You need to redirect users to `/api/v3/oauth2/authorize` endpoint to get an authorization code and include the parameters below.   This page will ask the user if they want to allow a client's application to submit or obtain data from their QM account. It will redirect the user to the url provided by the client application with the code as a query parameter or error in case of an error. See the /api/v1/oauth/access_token endpoint for the next steps.
 */
export const useGetOauthAuthorizationCode = (
  variables: GetOauthAuthorizationCodeVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      GetOauthAuthorizationCodeError,
      undefined
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useCuredaoContext(options);
  return reactQuery.useQuery<
    undefined,
    GetOauthAuthorizationCodeError,
    undefined
  >(
    queryKeyFn({
      path: "/v3/oauth2/authorize",
      operationId: "getOauthAuthorizationCode",
      variables,
    }),
    () => fetchGetOauthAuthorizationCode({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type GetAccessTokenQueryParams = {
  /*
   * Your CureDAO client id can be obtained by creating an app at https://builder.curedao.org
   */
  clientId?: string;
  /*
   * This is the secret for your obtained clientId. We use this to ensure that only your application uses the clientId.  Obtain this by creating a free application at [https://builder.curedao.org](https://builder.curedao.org).
   */
  client_secret?: string;
  /*
   * Grant Type can be 'authorization_code' or 'refresh_token'
   */
  grant_type: string;
  /*
   * Authorization code you received with the previous request.
   */
  code: string;
  /*
   * If the value is code, launches a Basic flow, requiring a POST to the token endpoint to obtain the tokens. If the value is token id_token or id_token token, launches an Implicit flow, requiring the use of Javascript at the redirect URI to retrieve tokens from the URI #fragment.
   */
  response_type: string;
  /*
   * Scopes include basic, readmeasurements, and writemeasurements. The `basic` scope allows you to read user info (displayName, email, etc). The `readmeasurements` scope allows one to read a user's data. The `writemeasurements` scope allows you to write user data. Separate multiple scopes by a space.
   */
  scope: string;
  /*
   * The redirect URI is the URL within your client application that will receive the OAuth2 credentials.
   */
  redirect_uri?: string;
  /*
   * An opaque string that is round-tripped in the protocol; that is to say, it is returned as a URI parameter in the Basic flow, and in the URI
   */
  state?: string;
};

export type GetAccessTokenError = Fetcher.ErrorWrapper<undefined>;

export type GetAccessTokenVariables = {
  queryParams: GetAccessTokenQueryParams;
} & CuredaoContext["fetcherOptions"];

/**
 * Client provides authorization token obtained from /api/v3/oauth2/authorize to this endpoint and  receives an access token. Access token can then be used to query API endpoints. ### Request Access Token After user approves your access to the given scope form the https:/api.curedao.org/v1/oauth2/authorize endpoint, you'll receive an authorization code to request an access token. This time make a `POST` request to `/api/v1/oauth/access_token` with parameters including: * `grant_type` Can be `authorization_code` or `refresh_token` since we are getting the `access_token` for the first time we don't have a `refresh_token` so this must be `authorization_code`. * `code` Authorization code you received with the previous request. * `redirect_uri` Your application's redirect url. ### Refreshing Access Token Access tokens expire at some point, to continue using our api you need to refresh them with `refresh_token` you received along with the `access_token`. To do this make a `POST` request to `/api/v1/oauth/access_token` with correct parameters, which are: * `grant_type` This time grant type must be `refresh_token` since we have it. * `clientId` Your application's client id. * `client_secret` Your application's client secret. * `refresh_token` The refresh token you received with the `access_token`. Every request you make to this endpoint will give you a new refresh token and make the old one expired. So you can keep getting new access tokens with new refresh tokens. ### Using Access Token Currently we support 2 ways for this, you can't use both at the same time. * Adding access token to the request header as `Authorization: Bearer {access_token}` * Adding to the url as a query parameter `?access_token={access_token}` You can read more about OAuth2 from [here](https://oauth.net/2/)
 */
export const fetchGetAccessToken = (variables: GetAccessTokenVariables) =>
  curedaoFetch<
    undefined,
    GetAccessTokenError,
    undefined,
    {},
    GetAccessTokenQueryParams,
    {}
  >({ url: "/v3/oauth2/token", method: "get", ...variables });

/**
 * Client provides authorization token obtained from /api/v3/oauth2/authorize to this endpoint and  receives an access token. Access token can then be used to query API endpoints. ### Request Access Token After user approves your access to the given scope form the https:/api.curedao.org/v1/oauth2/authorize endpoint, you'll receive an authorization code to request an access token. This time make a `POST` request to `/api/v1/oauth/access_token` with parameters including: * `grant_type` Can be `authorization_code` or `refresh_token` since we are getting the `access_token` for the first time we don't have a `refresh_token` so this must be `authorization_code`. * `code` Authorization code you received with the previous request. * `redirect_uri` Your application's redirect url. ### Refreshing Access Token Access tokens expire at some point, to continue using our api you need to refresh them with `refresh_token` you received along with the `access_token`. To do this make a `POST` request to `/api/v1/oauth/access_token` with correct parameters, which are: * `grant_type` This time grant type must be `refresh_token` since we have it. * `clientId` Your application's client id. * `client_secret` Your application's client secret. * `refresh_token` The refresh token you received with the `access_token`. Every request you make to this endpoint will give you a new refresh token and make the old one expired. So you can keep getting new access tokens with new refresh tokens. ### Using Access Token Currently we support 2 ways for this, you can't use both at the same time. * Adding access token to the request header as `Authorization: Bearer {access_token}` * Adding to the url as a query parameter `?access_token={access_token}` You can read more about OAuth2 from [here](https://oauth.net/2/)
 */
export const useGetAccessToken = (
  variables: GetAccessTokenVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetAccessTokenError, undefined>,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useCuredaoContext(options);
  return reactQuery.useQuery<undefined, GetAccessTokenError, undefined>(
    queryKeyFn({
      path: "/v3/oauth2/token",
      operationId: "getAccessToken",
      variables,
    }),
    () => fetchGetAccessToken({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type GetSharesQueryParams = {
  /*
   * User's id
   */
  userId?: number;
  /*
   * When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
   */
  createdAt?: string;
  /*
   * When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
   */
  updatedAt?: string;
  /*
   * Your CureDAO client id can be obtained by creating an app at https://builder.curedao.org
   */
  clientId?: string;
  /*
   * Ex: 2.1.1.0
   */
  appVersion?: string;
  /*
   * Username or email
   */
  log?: string;
  /*
   * User password
   */
  pwd?: string;
};

export type GetSharesError = Fetcher.ErrorWrapper<undefined>;

export type GetSharesVariables = {
  queryParams?: GetSharesQueryParams;
} & CuredaoContext["fetcherOptions"];

/**
 * This is a list of individuals, apps, or studies with access to your measurements.
 */
export const fetchGetShares = (variables: GetSharesVariables) =>
  curedaoFetch<
    Schemas.GetSharesResponse,
    GetSharesError,
    undefined,
    {},
    GetSharesQueryParams,
    {}
  >({ url: "/v3/shares", method: "get", ...variables });

/**
 * This is a list of individuals, apps, or studies with access to your measurements.
 */
export const useGetShares = (
  variables: GetSharesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.GetSharesResponse,
      GetSharesError,
      Schemas.GetSharesResponse
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useCuredaoContext(options);
  return reactQuery.useQuery<
    Schemas.GetSharesResponse,
    GetSharesError,
    Schemas.GetSharesResponse
  >(
    queryKeyFn({ path: "/v3/shares", operationId: "getShares", variables }),
    () => fetchGetShares({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type DeleteShareQueryParams = {
  /*
   * Client id of the individual, study, or app that the user wishes to no longer have access to their data
   */
  clientIdToRevoke: string;
  /*
   * Ex: I hate you!
   */
  reason?: string;
};

export type DeleteShareError = Fetcher.ErrorWrapper<undefined>;

export type DeleteShareVariables = {
  queryParams: DeleteShareQueryParams;
} & CuredaoContext["fetcherOptions"];

/**
 * Remove access to user data for a given client_id associated with a given individual, app, or study
 */
export const fetchDeleteShare = (variables: DeleteShareVariables) =>
  curedaoFetch<
    Schemas.User,
    DeleteShareError,
    undefined,
    {},
    DeleteShareQueryParams,
    {}
  >({ url: "/v3/shares/delete", method: "post", ...variables });

/**
 * Remove access to user data for a given client_id associated with a given individual, app, or study
 */
export const useDeleteShare = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.User,
      DeleteShareError,
      DeleteShareVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useCuredaoContext();
  return reactQuery.useMutation<
    Schemas.User,
    DeleteShareError,
    DeleteShareVariables
  >(
    (variables: DeleteShareVariables) =>
      fetchDeleteShare({ ...fetcherOptions, ...variables }),
    options
  );
};

export type InviteShareQueryParams = {
  /*
   * Your CureDAO client id can be obtained by creating an app at https://builder.curedao.org
   */
  clientId?: string;
};

export type InviteShareError = Fetcher.ErrorWrapper<undefined>;

export type InviteShareVariables = {
  body: Schemas.ShareInvitationBody;
  queryParams?: InviteShareQueryParams;
} & CuredaoContext["fetcherOptions"];

/**
 * Invite someone to view your measurements
 */
export const fetchInviteShare = (variables: InviteShareVariables) =>
  curedaoFetch<
    Schemas.User,
    InviteShareError,
    Schemas.ShareInvitationBody,
    {},
    InviteShareQueryParams,
    {}
  >({ url: "/v3/shares/invite", method: "post", ...variables });

/**
 * Invite someone to view your measurements
 */
export const useInviteShare = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.User,
      InviteShareError,
      InviteShareVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useCuredaoContext();
  return reactQuery.useMutation<
    Schemas.User,
    InviteShareError,
    InviteShareVariables
  >(
    (variables: InviteShareVariables) =>
      fetchInviteShare({ ...fetcherOptions, ...variables }),
    options
  );
};

export type GetStudiesQueryParams = {
  /*
   * Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
   */
  causeVariableName?: string;
  /*
   * Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
   */
  effectVariableName?: string;
  /*
   * User's id
   */
  userId?: number;
  /*
   * Your CureDAO client id can be obtained by creating an app at https://builder.curedao.org
   */
  clientId?: string;
  /*
   * Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
   */
  includeCharts?: boolean;
  /*
   * Recalculate instead of using cached analysis
   */
  recalculate?: boolean;
  /*
   * Client id for the study you want
   */
  studyId?: string;
  /*
   * Sort by one of the listed field names. If the field name is prefixed with `-`, it will sort in descending order.
   */
  sort?: string;
  /*
   * The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
   *
   * @default 100
   */
  limit?: number;
  /*
   * OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
   *
   * @minimum 0
   */
  offset?: number;
  /*
   * Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action
   */
  correlationCoefficient?: string;
  /*
   * When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
   */
  updatedAt?: string;
  /*
   * Only include correlations for which the effect is an outcome of interest for the user
   */
  outcomesOfInterest?: boolean;
  /*
   * These are studies created by a specific principal investigator
   */
  principalInvestigatorUserId?: number;
  /*
   * These are studies that anyone can join
   */
  open?: boolean;
  /*
   * These are studies that you have joined
   */
  joined?: boolean;
  /*
   * These are studies that you have created
   */
  created?: boolean;
  /*
   * These are aggregated n=1 studies based on the entire population of users that have shared their data
   */
  aggregated?: boolean;
  /*
   * These are studies that you have down-voted
   */
  downvoted?: boolean;
};

export type GetStudiesError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Schemas.JsonErrorResponse;
}>;

export type GetStudiesVariables = {
  queryParams?: GetStudiesQueryParams;
} & CuredaoContext["fetcherOptions"];

/**
 * If you have enough data, this will be a list of your personal studies, otherwise it will consist of aggregated population studies.
 */
export const fetchGetStudies = (variables: GetStudiesVariables) =>
  curedaoFetch<
    Schemas.GetStudiesResponse,
    GetStudiesError,
    undefined,
    {},
    GetStudiesQueryParams,
    {}
  >({ url: "/v3/studies", method: "get", ...variables });

/**
 * If you have enough data, this will be a list of your personal studies, otherwise it will consist of aggregated population studies.
 */
export const useGetStudies = (
  variables: GetStudiesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.GetStudiesResponse,
      GetStudiesError,
      Schemas.GetStudiesResponse
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useCuredaoContext(options);
  return reactQuery.useQuery<
    Schemas.GetStudiesResponse,
    GetStudiesError,
    Schemas.GetStudiesResponse
  >(
    queryKeyFn({ path: "/v3/studies", operationId: "getStudies", variables }),
    () => fetchGetStudies({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type GetOpenStudiesQueryParams = {
  /*
   * Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
   */
  causeVariableName?: string;
  /*
   * Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
   */
  effectVariableName?: string;
  /*
   * User's id
   */
  userId?: number;
  /*
   * Your CureDAO client id can be obtained by creating an app at https://builder.curedao.org
   */
  clientId?: string;
  /*
   * Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
   */
  includeCharts?: boolean;
  /*
   * Recalculate instead of using cached analysis
   */
  recalculate?: boolean;
  /*
   * Client id for the study you want
   */
  studyId?: string;
};

export type GetOpenStudiesError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Schemas.JsonErrorResponse;
}>;

export type GetOpenStudiesVariables = {
  queryParams?: GetOpenStudiesQueryParams;
} & CuredaoContext["fetcherOptions"];

/**
 * These are studies that anyone can join and share their data for the predictor and outcome variables of interest.
 */
export const fetchGetOpenStudies = (variables: GetOpenStudiesVariables) =>
  curedaoFetch<
    Schemas.GetStudiesResponse,
    GetOpenStudiesError,
    undefined,
    {},
    GetOpenStudiesQueryParams,
    {}
  >({ url: "/v3/studies/open", method: "get", ...variables });

/**
 * These are studies that anyone can join and share their data for the predictor and outcome variables of interest.
 */
export const useGetOpenStudies = (
  variables: GetOpenStudiesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.GetStudiesResponse,
      GetOpenStudiesError,
      Schemas.GetStudiesResponse
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useCuredaoContext(options);
  return reactQuery.useQuery<
    Schemas.GetStudiesResponse,
    GetOpenStudiesError,
    Schemas.GetStudiesResponse
  >(
    queryKeyFn({
      path: "/v3/studies/open",
      operationId: "getOpenStudies",
      variables,
    }),
    () => fetchGetOpenStudies({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type GetStudiesJoinedQueryParams = {
  /*
   * Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
   */
  causeVariableName?: string;
  /*
   * Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
   */
  effectVariableName?: string;
  /*
   * Sort by one of the listed field names. If the field name is prefixed with `-`, it will sort in descending order.
   */
  sort?: string;
  /*
   * The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
   *
   * @default 100
   */
  limit?: number;
  /*
   * OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
   *
   * @minimum 0
   */
  offset?: number;
  /*
   * User's id
   */
  userId?: number;
  /*
   * Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action
   */
  correlationCoefficient?: string;
  /*
   * When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
   */
  updatedAt?: string;
  /*
   * Only include correlations for which the effect is an outcome of interest for the user
   */
  outcomesOfInterest?: boolean;
  /*
   * Your CureDAO client id can be obtained by creating an app at https://builder.curedao.org
   */
  clientId?: string;
};

export type GetStudiesJoinedError = Fetcher.ErrorWrapper<undefined>;

export type GetStudiesJoinedVariables = {
  queryParams?: GetStudiesJoinedQueryParams;
} & CuredaoContext["fetcherOptions"];

/**
 * These are studies that you are currently sharing your data with.
 */
export const fetchGetStudiesJoined = (variables: GetStudiesJoinedVariables) =>
  curedaoFetch<
    Schemas.GetStudiesResponse,
    GetStudiesJoinedError,
    undefined,
    {},
    GetStudiesJoinedQueryParams,
    {}
  >({ url: "/v3/studies/joined", method: "get", ...variables });

/**
 * These are studies that you are currently sharing your data with.
 */
export const useGetStudiesJoined = (
  variables: GetStudiesJoinedVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.GetStudiesResponse,
      GetStudiesJoinedError,
      Schemas.GetStudiesResponse
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useCuredaoContext(options);
  return reactQuery.useQuery<
    Schemas.GetStudiesResponse,
    GetStudiesJoinedError,
    Schemas.GetStudiesResponse
  >(
    queryKeyFn({
      path: "/v3/studies/joined",
      operationId: "getStudiesJoined",
      variables,
    }),
    () => fetchGetStudiesJoined({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type GetStudiesCreatedQueryParams = {
  /*
   * Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
   */
  causeVariableName?: string;
  /*
   * Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
   */
  effectVariableName?: string;
  /*
   * Sort by one of the listed field names. If the field name is prefixed with `-`, it will sort in descending order.
   */
  sort?: string;
  /*
   * The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
   *
   * @default 100
   */
  limit?: number;
  /*
   * OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
   *
   * @minimum 0
   */
  offset?: number;
  /*
   * User's id
   */
  userId?: number;
  /*
   * When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
   */
  updatedAt?: string;
  /*
   * Your CureDAO client id can be obtained by creating an app at https://builder.curedao.org
   */
  clientId?: string;
};

export type GetStudiesCreatedError = Fetcher.ErrorWrapper<undefined>;

export type GetStudiesCreatedVariables = {
  queryParams?: GetStudiesCreatedQueryParams;
} & CuredaoContext["fetcherOptions"];

/**
 * These are studies that you have created.
 */
export const fetchGetStudiesCreated = (variables: GetStudiesCreatedVariables) =>
  curedaoFetch<
    Schemas.GetStudiesResponse,
    GetStudiesCreatedError,
    undefined,
    {},
    GetStudiesCreatedQueryParams,
    {}
  >({ url: "/v3/studies/created", method: "get", ...variables });

/**
 * These are studies that you have created.
 */
export const useGetStudiesCreated = (
  variables: GetStudiesCreatedVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.GetStudiesResponse,
      GetStudiesCreatedError,
      Schemas.GetStudiesResponse
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useCuredaoContext(options);
  return reactQuery.useQuery<
    Schemas.GetStudiesResponse,
    GetStudiesCreatedError,
    Schemas.GetStudiesResponse
  >(
    queryKeyFn({
      path: "/v3/studies/created",
      operationId: "getStudiesCreated",
      variables,
    }),
    () => fetchGetStudiesCreated({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type PublishStudyQueryParams = {
  /*
   * Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
   */
  causeVariableName?: string;
  /*
   * Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
   */
  effectVariableName?: string;
  /*
   * User's id
   */
  userId?: number;
  /*
   * Your CureDAO client id can be obtained by creating an app at https://builder.curedao.org
   */
  clientId?: string;
  /*
   * Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
   */
  includeCharts?: boolean;
  /*
   * Recalculate instead of using cached analysis
   */
  recalculate?: boolean;
  /*
   * Client id for the study you want
   */
  studyId?: string;
};

export type PublishStudyError = Fetcher.ErrorWrapper<undefined>;

export type PublishStudyVariables = {
  queryParams?: PublishStudyQueryParams;
} & CuredaoContext["fetcherOptions"];

/**
 * Make a study and all related measurements publicly visible by anyone
 */
export const fetchPublishStudy = (variables: PublishStudyVariables) =>
  curedaoFetch<
    Schemas.PostStudyPublishResponse,
    PublishStudyError,
    undefined,
    {},
    PublishStudyQueryParams,
    {}
  >({ url: "/v3/study/publish", method: "post", ...variables });

/**
 * Make a study and all related measurements publicly visible by anyone
 */
export const usePublishStudy = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.PostStudyPublishResponse,
      PublishStudyError,
      PublishStudyVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useCuredaoContext();
  return reactQuery.useMutation<
    Schemas.PostStudyPublishResponse,
    PublishStudyError,
    PublishStudyVariables
  >(
    (variables: PublishStudyVariables) =>
      fetchPublishStudy({ ...fetcherOptions, ...variables }),
    options
  );
};

export type JoinStudyQueryParams = {
  /*
   * Client id for the study you want
   */
  studyId?: string;
  /*
   * Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
   */
  causeVariableName?: string;
  /*
   * Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
   */
  effectVariableName?: string;
  /*
   * User's id
   */
  userId?: number;
  /*
   * Your CureDAO client id can be obtained by creating an app at https://builder.curedao.org
   */
  clientId?: string;
};

export type JoinStudyError = Fetcher.ErrorWrapper<undefined>;

export type JoinStudyVariables = {
  queryParams?: JoinStudyQueryParams;
} & CuredaoContext["fetcherOptions"];

/**
 * Anonymously share measurements for specified variables
 */
export const fetchJoinStudy = (variables: JoinStudyVariables) =>
  curedaoFetch<
    Schemas.StudyJoinResponse,
    JoinStudyError,
    undefined,
    {},
    JoinStudyQueryParams,
    {}
  >({ url: "/v3/study/join", method: "post", ...variables });

/**
 * Anonymously share measurements for specified variables
 */
export const useJoinStudy = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.StudyJoinResponse,
      JoinStudyError,
      JoinStudyVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useCuredaoContext();
  return reactQuery.useMutation<
    Schemas.StudyJoinResponse,
    JoinStudyError,
    JoinStudyVariables
  >(
    (variables: JoinStudyVariables) =>
      fetchJoinStudy({ ...fetcherOptions, ...variables }),
    options
  );
};

export type CreateStudyQueryParams = {
  /*
   * Your CureDAO client id can be obtained by creating an app at https://builder.curedao.org
   */
  clientId?: string;
};

export type CreateStudyError = Fetcher.ErrorWrapper<undefined>;

export type CreateStudyVariables = {
  body: Schemas.StudyCreationBody;
  queryParams?: CreateStudyQueryParams;
} & CuredaoContext["fetcherOptions"];

/**
 * Create an individual, group, or population study examining the relationship between a predictor and outcome variable. You will be given a study id which you can invite participants to join and share their measurements for the specified variables.
 */
export const fetchCreateStudy = (variables: CreateStudyVariables) =>
  curedaoFetch<
    Schemas.PostStudyCreateResponse,
    CreateStudyError,
    Schemas.StudyCreationBody,
    {},
    CreateStudyQueryParams,
    {}
  >({ url: "/v3/study/create", method: "post", ...variables });

/**
 * Create an individual, group, or population study examining the relationship between a predictor and outcome variable. You will be given a study id which you can invite participants to join and share their measurements for the specified variables.
 */
export const useCreateStudy = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.PostStudyCreateResponse,
      CreateStudyError,
      CreateStudyVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useCuredaoContext();
  return reactQuery.useMutation<
    Schemas.PostStudyCreateResponse,
    CreateStudyError,
    CreateStudyVariables
  >(
    (variables: CreateStudyVariables) =>
      fetchCreateStudy({ ...fetcherOptions, ...variables }),
    options
  );
};

export type GetTrackingReminderNotificationsQueryParams = {
  /*
   * Sort by one of the listed field names. If the field name is prefixed with `-`, it will sort in descending order.
   */
  sort?: string;
  /*
   * User's id
   */
  userId?: number;
  /*
   * When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
   */
  createdAt?: string;
  /*
   * When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
   */
  updatedAt?: string;
  /*
   * The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
   *
   * @default 100
   */
  limit?: number;
  /*
   * OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
   *
   * @minimum 0
   */
  offset?: number;
  /*
   * Ex: Emotions, Treatments, Symptoms...
   */
  variableCategoryName?:
    | "Activities"
    | "Books"
    | "Causes of Illness"
    | "Cognitive Performance"
    | "Conditions"
    | "Emotions"
    | "Environment"
    | "Foods"
    | "Location"
    | "Miscellaneous"
    | "Movies and TV"
    | "Music"
    | "Nutrients"
    | "Payments"
    | "Physical Activity"
    | "Physique"
    | "Sleep"
    | "Social Interactions"
    | "Software"
    | "Symptoms"
    | "Treatments"
    | "Vital Signs"
    | "Goals";
  /*
   * Ex: (lt)2017-07-31 21:43:26
   */
  reminderTime?: string;
  /*
   * Your CureDAO client id can be obtained by creating an app at https://builder.curedao.org
   */
  clientId?: string;
  /*
   * Ex: 1
   */
  onlyPast?: boolean;
  /*
   * Include deleted variables
   */
  includeDeleted?: boolean;
};

export type GetTrackingReminderNotificationsError =
  Fetcher.ErrorWrapper<undefined>;

export type GetTrackingReminderNotificationsVariables = {
  queryParams?: GetTrackingReminderNotificationsQueryParams;
} & CuredaoContext["fetcherOptions"];

/**
 * Specific tracking reminder notification instances that still need to be tracked.
 */
export const fetchGetTrackingReminderNotifications = (
  variables: GetTrackingReminderNotificationsVariables
) =>
  curedaoFetch<
    Schemas.GetTrackingReminderNotificationsResponse,
    GetTrackingReminderNotificationsError,
    undefined,
    {},
    GetTrackingReminderNotificationsQueryParams,
    {}
  >({ url: "/v3/trackingReminderNotifications", method: "get", ...variables });

/**
 * Specific tracking reminder notification instances that still need to be tracked.
 */
export const useGetTrackingReminderNotifications = (
  variables: GetTrackingReminderNotificationsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.GetTrackingReminderNotificationsResponse,
      GetTrackingReminderNotificationsError,
      Schemas.GetTrackingReminderNotificationsResponse
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useCuredaoContext(options);
  return reactQuery.useQuery<
    Schemas.GetTrackingReminderNotificationsResponse,
    GetTrackingReminderNotificationsError,
    Schemas.GetTrackingReminderNotificationsResponse
  >(
    queryKeyFn({
      path: "/v3/trackingReminderNotifications",
      operationId: "getTrackingReminderNotifications",
      variables,
    }),
    () =>
      fetchGetTrackingReminderNotifications({
        ...fetcherOptions,
        ...variables,
      }),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type PostTrackingReminderNotificationsQueryParams = {
  /*
   * User's id
   */
  userId?: number;
  /*
   * Your CureDAO client id can be obtained by creating an app at https://builder.curedao.org
   */
  clientId?: string;
};

export type PostTrackingReminderNotificationsError =
  Fetcher.ErrorWrapper<undefined>;

export type PostTrackingReminderNotificationsRequestBody =
  Schemas.TrackingReminderNotificationPost[];

export type PostTrackingReminderNotificationsVariables = {
  body?: PostTrackingReminderNotificationsRequestBody;
  queryParams?: PostTrackingReminderNotificationsQueryParams;
} & CuredaoContext["fetcherOptions"];

/**
 * Snooze, skip, or track a tracking reminder notification
 */
export const fetchPostTrackingReminderNotifications = (
  variables: PostTrackingReminderNotificationsVariables
) =>
  curedaoFetch<
    Schemas.CommonResponse,
    PostTrackingReminderNotificationsError,
    PostTrackingReminderNotificationsRequestBody,
    {},
    PostTrackingReminderNotificationsQueryParams,
    {}
  >({ url: "/v3/trackingReminderNotifications", method: "post", ...variables });

/**
 * Snooze, skip, or track a tracking reminder notification
 */
export const usePostTrackingReminderNotifications = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CommonResponse,
      PostTrackingReminderNotificationsError,
      PostTrackingReminderNotificationsVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useCuredaoContext();
  return reactQuery.useMutation<
    Schemas.CommonResponse,
    PostTrackingReminderNotificationsError,
    PostTrackingReminderNotificationsVariables
  >(
    (variables: PostTrackingReminderNotificationsVariables) =>
      fetchPostTrackingReminderNotifications({
        ...fetcherOptions,
        ...variables,
      }),
    options
  );
};

export type GetTrackingRemindersQueryParams = {
  /*
   * User's id
   */
  userId?: number;
  /*
   * Ex: Emotions, Treatments, Symptoms...
   */
  variableCategoryName?:
    | "Activities"
    | "Books"
    | "Causes of Illness"
    | "Cognitive Performance"
    | "Conditions"
    | "Emotions"
    | "Environment"
    | "Foods"
    | "Location"
    | "Miscellaneous"
    | "Movies and TV"
    | "Music"
    | "Nutrients"
    | "Payments"
    | "Physical Activity"
    | "Physique"
    | "Sleep"
    | "Social Interactions"
    | "Software"
    | "Symptoms"
    | "Treatments"
    | "Vital Signs"
    | "Goals";
  /*
   * When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
   */
  createdAt?: string;
  /*
   * When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
   */
  updatedAt?: string;
  /*
   * The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
   *
   * @default 100
   */
  limit?: number;
  /*
   * OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
   *
   * @minimum 0
   */
  offset?: number;
  /*
   * Sort by one of the listed field names. If the field name is prefixed with `-`, it will sort in descending order.
   */
  sort?: string;
  /*
   * Your CureDAO client id can be obtained by creating an app at https://builder.curedao.org
   */
  clientId?: string;
  /*
   * Ex: 2.1.1.0
   */
  appVersion?: string;
};

export type GetTrackingRemindersError = Fetcher.ErrorWrapper<undefined>;

export type GetTrackingRemindersResponse = Schemas.TrackingReminder[];

export type GetTrackingRemindersVariables = {
  queryParams?: GetTrackingRemindersQueryParams;
} & CuredaoContext["fetcherOptions"];

/**
 * Users can be reminded to track certain variables at a specified frequency with a default value.
 */
export const fetchGetTrackingReminders = (
  variables: GetTrackingRemindersVariables
) =>
  curedaoFetch<
    GetTrackingRemindersResponse,
    GetTrackingRemindersError,
    undefined,
    {},
    GetTrackingRemindersQueryParams,
    {}
  >({ url: "/v3/trackingReminders", method: "get", ...variables });

/**
 * Users can be reminded to track certain variables at a specified frequency with a default value.
 */
export const useGetTrackingReminders = (
  variables: GetTrackingRemindersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetTrackingRemindersResponse,
      GetTrackingRemindersError,
      GetTrackingRemindersResponse
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useCuredaoContext(options);
  return reactQuery.useQuery<
    GetTrackingRemindersResponse,
    GetTrackingRemindersError,
    GetTrackingRemindersResponse
  >(
    queryKeyFn({
      path: "/v3/trackingReminders",
      operationId: "getTrackingReminders",
      variables,
    }),
    () => fetchGetTrackingReminders({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type PostTrackingRemindersError = Fetcher.ErrorWrapper<undefined>;

export type PostTrackingRemindersRequestBody = Schemas.TrackingReminder[];

export type PostTrackingRemindersVariables = {
  body?: PostTrackingRemindersRequestBody;
} & CuredaoContext["fetcherOptions"];

/**
 * This is to enable users to create reminders to track a variable with a default value at a specified frequency
 */
export const fetchPostTrackingReminders = (
  variables: PostTrackingRemindersVariables
) =>
  curedaoFetch<
    Schemas.PostTrackingRemindersResponse,
    PostTrackingRemindersError,
    PostTrackingRemindersRequestBody,
    {},
    {},
    {}
  >({ url: "/v3/trackingReminders", method: "post", ...variables });

/**
 * This is to enable users to create reminders to track a variable with a default value at a specified frequency
 */
export const usePostTrackingReminders = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.PostTrackingRemindersResponse,
      PostTrackingRemindersError,
      PostTrackingRemindersVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useCuredaoContext();
  return reactQuery.useMutation<
    Schemas.PostTrackingRemindersResponse,
    PostTrackingRemindersError,
    PostTrackingRemindersVariables
  >(
    (variables: PostTrackingRemindersVariables) =>
      fetchPostTrackingReminders({ ...fetcherOptions, ...variables }),
    options
  );
};

export type DeleteTrackingReminderQueryParams = {
  /*
   * User's id
   */
  userId?: number;
};

export type DeleteTrackingReminderError = Fetcher.ErrorWrapper<undefined>;

export type DeleteTrackingReminderVariables = {
  queryParams?: DeleteTrackingReminderQueryParams;
} & CuredaoContext["fetcherOptions"];

/**
 * Stop getting notifications to record data for a variable.  Previously recorded measurements will be preserved.
 */
export const fetchDeleteTrackingReminder = (
  variables: DeleteTrackingReminderVariables
) =>
  curedaoFetch<
    Schemas.CommonResponse,
    DeleteTrackingReminderError,
    undefined,
    {},
    DeleteTrackingReminderQueryParams,
    {}
  >({ url: "/v3/trackingReminders/delete", method: "delete", ...variables });

/**
 * Stop getting notifications to record data for a variable.  Previously recorded measurements will be preserved.
 */
export const useDeleteTrackingReminder = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CommonResponse,
      DeleteTrackingReminderError,
      DeleteTrackingReminderVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useCuredaoContext();
  return reactQuery.useMutation<
    Schemas.CommonResponse,
    DeleteTrackingReminderError,
    DeleteTrackingReminderVariables
  >(
    (variables: DeleteTrackingReminderVariables) =>
      fetchDeleteTrackingReminder({ ...fetcherOptions, ...variables }),
    options
  );
};

export type GetUnitCategoriesError = Fetcher.ErrorWrapper<undefined>;

export type GetUnitCategoriesResponse = Schemas.UnitCategory[];

export type GetUnitCategoriesVariables = CuredaoContext["fetcherOptions"];

/**
 * Get a list of the categories of measurement units such as 'Distance', 'Duration', 'Energy', 'Frequency', 'Miscellany', 'Pressure', 'Proportion', 'Rating', 'Temperature', 'Volume', and 'Weight'.
 */
export const fetchGetUnitCategories = (variables: GetUnitCategoriesVariables) =>
  curedaoFetch<
    GetUnitCategoriesResponse,
    GetUnitCategoriesError,
    undefined,
    {},
    {},
    {}
  >({ url: "/v3/unitCategories", method: "get", ...variables });

/**
 * Get a list of the categories of measurement units such as 'Distance', 'Duration', 'Energy', 'Frequency', 'Miscellany', 'Pressure', 'Proportion', 'Rating', 'Temperature', 'Volume', and 'Weight'.
 */
export const useGetUnitCategories = (
  variables: GetUnitCategoriesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetUnitCategoriesResponse,
      GetUnitCategoriesError,
      GetUnitCategoriesResponse
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useCuredaoContext(options);
  return reactQuery.useQuery<
    GetUnitCategoriesResponse,
    GetUnitCategoriesError,
    GetUnitCategoriesResponse
  >(
    queryKeyFn({
      path: "/v3/unitCategories",
      operationId: "getUnitCategories",
      variables,
    }),
    () => fetchGetUnitCategories({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type GetUserQueryParams = {
  /*
   * User's id
   */
  userId?: number;
  /*
   * When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
   */
  createdAt?: string;
  /*
   * When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
   */
  updatedAt?: string;
  /*
   * The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
   *
   * @default 100
   */
  limit?: number;
  /*
   * OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
   *
   * @minimum 0
   */
  offset?: number;
  /*
   * Sort by one of the listed field names. If the field name is prefixed with `-`, it will sort in descending order.
   */
  sort?: string;
  /*
   * Your CureDAO client id can be obtained by creating an app at https://builder.curedao.org
   */
  clientId?: string;
  /*
   * Ex: 2.1.1.0
   */
  appVersion?: string;
  /*
   * Ex: 74802
   */
  clientUserId?: number;
  /*
   * Username or email
   */
  log?: string;
  /*
   * User password
   */
  pwd?: string;
  /*
   * Return list of apps, studies, and individuals with access to user data
   */
  includeAuthorizedClients?: boolean;
};

export type GetUserError = Fetcher.ErrorWrapper<undefined>;

export type GetUserVariables = {
  queryParams?: GetUserQueryParams;
} & CuredaoContext["fetcherOptions"];

/**
 * Returns user info.  If no userId is specified, returns info for currently authenticated user
 */
export const fetchGetUser = (variables: GetUserVariables) =>
  curedaoFetch<
    Schemas.User,
    GetUserError,
    undefined,
    {},
    GetUserQueryParams,
    {}
  >({ url: "/v3/user", method: "get", ...variables });

/**
 * Returns user info.  If no userId is specified, returns info for currently authenticated user
 */
export const useGetUser = (
  variables: GetUserVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.User, GetUserError, Schemas.User>,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useCuredaoContext(options);
  return reactQuery.useQuery<Schemas.User, GetUserError, Schemas.User>(
    queryKeyFn({ path: "/v3/user", operationId: "getUser", variables }),
    () => fetchGetUser({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type GetUsersQueryParams = {
  /*
   * User's id
   */
  userId?: number;
  /*
   * When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
   */
  createdAt?: string;
  /*
   * When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
   */
  updatedAt?: string;
  /*
   * The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
   *
   * @default 100
   */
  limit?: number;
  /*
   * OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
   *
   * @minimum 0
   */
  offset?: number;
  /*
   * Sort by one of the listed field names. If the field name is prefixed with `-`, it will sort in descending order.
   */
  sort?: string;
  /*
   * Your CureDAO client id can be obtained by creating an app at https://builder.curedao.org
   */
  clientId?: string;
  /*
   * Ex: 2.1.1.0
   */
  appVersion?: string;
  /*
   * Ex: 74802
   */
  clientUserId?: number;
  /*
   * Username or email
   */
  log?: string;
  /*
   * User password
   */
  pwd?: string;
};

export type GetUsersError = Fetcher.ErrorWrapper<undefined>;

export type GetUsersVariables = {
  queryParams?: GetUsersQueryParams;
} & CuredaoContext["fetcherOptions"];

/**
 * Returns users who have granted access to their data
 */
export const fetchGetUsers = (variables: GetUsersVariables) =>
  curedaoFetch<
    Schemas.UsersResponse,
    GetUsersError,
    undefined,
    {},
    GetUsersQueryParams,
    {}
  >({ url: "/v3/users", method: "get", ...variables });

/**
 * Returns users who have granted access to their data
 */
export const useGetUsers = (
  variables: GetUsersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.UsersResponse,
      GetUsersError,
      Schemas.UsersResponse
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useCuredaoContext(options);
  return reactQuery.useQuery<
    Schemas.UsersResponse,
    GetUsersError,
    Schemas.UsersResponse
  >(
    queryKeyFn({ path: "/v3/users", operationId: "getUsers", variables }),
    () => fetchGetUsers({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type DeleteUserQueryParams = {
  /*
   * Your CureDAO client id can be obtained by creating an app at https://builder.curedao.org
   */
  clientId?: string;
  /*
   * Ex: I hate you!
   */
  reason: string;
};

export type DeleteUserError = Fetcher.ErrorWrapper<undefined>;

export type DeleteUserVariables = {
  queryParams: DeleteUserQueryParams;
} & CuredaoContext["fetcherOptions"];

/**
 * Delete user account. Only the client app that created a user can delete that user.
 */
export const fetchDeleteUser = (variables: DeleteUserVariables) =>
  curedaoFetch<
    Schemas.CommonResponse,
    DeleteUserError,
    undefined,
    {},
    DeleteUserQueryParams,
    {}
  >({ url: "/v3/user/delete", method: "delete", ...variables });

/**
 * Delete user account. Only the client app that created a user can delete that user.
 */
export const useDeleteUser = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CommonResponse,
      DeleteUserError,
      DeleteUserVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useCuredaoContext();
  return reactQuery.useMutation<
    Schemas.CommonResponse,
    DeleteUserError,
    DeleteUserVariables
  >(
    (variables: DeleteUserVariables) =>
      fetchDeleteUser({ ...fetcherOptions, ...variables }),
    options
  );
};

export type PostUserSettingsQueryParams = {
  /*
   * Your CureDAO client id can be obtained by creating an app at https://builder.curedao.org
   */
  clientId?: string;
};

export type PostUserSettingsError = Fetcher.ErrorWrapper<undefined>;

export type PostUserSettingsVariables = {
  body: Schemas.User;
  queryParams?: PostUserSettingsQueryParams;
} & CuredaoContext["fetcherOptions"];

/**
 * Post UserSettings
 */
export const fetchPostUserSettings = (variables: PostUserSettingsVariables) =>
  curedaoFetch<
    Schemas.PostUserSettingsResponse,
    PostUserSettingsError,
    Schemas.User,
    {},
    PostUserSettingsQueryParams,
    {}
  >({ url: "/v3/userSettings", method: "post", ...variables });

/**
 * Post UserSettings
 */
export const usePostUserSettings = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.PostUserSettingsResponse,
      PostUserSettingsError,
      PostUserSettingsVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useCuredaoContext();
  return reactQuery.useMutation<
    Schemas.PostUserSettingsResponse,
    PostUserSettingsError,
    PostUserSettingsVariables
  >(
    (variables: PostUserSettingsVariables) =>
      fetchPostUserSettings({ ...fetcherOptions, ...variables }),
    options
  );
};

export type PostUserTagsQueryParams = {
  /*
   * User's id
   */
  userId?: number;
};

export type PostUserTagsError = Fetcher.ErrorWrapper<undefined>;

export type PostUserTagsVariables = {
  body: Schemas.UserTag;
  queryParams?: PostUserTagsQueryParams;
} & CuredaoContext["fetcherOptions"];

/**
 * This endpoint allows users to tag foods with their ingredients.  This information will then be used to infer the user intake of the different ingredients by just entering the foods. The inferred intake levels will then be used to determine the effects of different nutrients on the user during analysis.
 */
export const fetchPostUserTags = (variables: PostUserTagsVariables) =>
  curedaoFetch<
    Schemas.CommonResponse,
    PostUserTagsError,
    Schemas.UserTag,
    {},
    PostUserTagsQueryParams,
    {}
  >({ url: "/v3/userTags", method: "post", ...variables });

/**
 * This endpoint allows users to tag foods with their ingredients.  This information will then be used to infer the user intake of the different ingredients by just entering the foods. The inferred intake levels will then be used to determine the effects of different nutrients on the user during analysis.
 */
export const usePostUserTags = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CommonResponse,
      PostUserTagsError,
      PostUserTagsVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useCuredaoContext();
  return reactQuery.useMutation<
    Schemas.CommonResponse,
    PostUserTagsError,
    PostUserTagsVariables
  >(
    (variables: PostUserTagsVariables) =>
      fetchPostUserTags({ ...fetcherOptions, ...variables }),
    options
  );
};

export type DeleteUserTagQueryParams = {
  /*
   * Id of the tagged variable (i.e. Lollipop) you would like to get variables it can be tagged with (i.e. Sugar).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
   */
  taggedVariableId?: number;
  /*
   * Id of the tag variable (i.e. Sugar) you would like to get variables it can be tagged to (i.e. Lollipop).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
   */
  tagVariableId?: number;
};

export type DeleteUserTagError = Fetcher.ErrorWrapper<undefined>;

export type DeleteUserTagVariables = {
  queryParams?: DeleteUserTagQueryParams;
} & CuredaoContext["fetcherOptions"];

/**
 * Delete previously created user tags or ingredients.
 */
export const fetchDeleteUserTag = (variables: DeleteUserTagVariables) =>
  curedaoFetch<
    Schemas.CommonResponse,
    DeleteUserTagError,
    undefined,
    {},
    DeleteUserTagQueryParams,
    {}
  >({ url: "/v3/userTags/delete", method: "delete", ...variables });

/**
 * Delete previously created user tags or ingredients.
 */
export const useDeleteUserTag = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CommonResponse,
      DeleteUserTagError,
      DeleteUserTagVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useCuredaoContext();
  return reactQuery.useMutation<
    Schemas.CommonResponse,
    DeleteUserTagError,
    DeleteUserTagVariables
  >(
    (variables: DeleteUserTagVariables) =>
      fetchDeleteUserTag({ ...fetcherOptions, ...variables }),
    options
  );
};

export type DeleteUserVariableError = Fetcher.ErrorWrapper<undefined>;

export type DeleteUserVariableVariables = CuredaoContext["fetcherOptions"];

/**
 * Users can delete all of their measurements for a variable
 */
export const fetchDeleteUserVariable = (
  variables: DeleteUserVariableVariables
) =>
  curedaoFetch<undefined, DeleteUserVariableError, undefined, {}, {}, {}>({
    url: "/v3/userVariables/delete",
    method: "delete",
    ...variables,
  });

/**
 * Users can delete all of their measurements for a variable
 */
export const useDeleteUserVariable = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteUserVariableError,
      DeleteUserVariableVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useCuredaoContext();
  return reactQuery.useMutation<
    undefined,
    DeleteUserVariableError,
    DeleteUserVariableVariables
  >(
    (variables: DeleteUserVariableVariables) =>
      fetchDeleteUserVariable({ ...fetcherOptions, ...variables }),
    options
  );
};

export type ResetUserVariableSettingsError = Fetcher.ErrorWrapper<undefined>;

export type ResetUserVariableSettingsVariables = {
  body: RequestBodies.VariableIdBodyParam;
} & CuredaoContext["fetcherOptions"];

/**
 * Reset user settings for a variable to defaults
 */
export const fetchResetUserVariableSettings = (
  variables: ResetUserVariableSettingsVariables
) =>
  curedaoFetch<
    undefined,
    ResetUserVariableSettingsError,
    RequestBodies.VariableIdBodyParam,
    {},
    {},
    {}
  >({ url: "/v3/userVariables/reset", method: "post", ...variables });

/**
 * Reset user settings for a variable to defaults
 */
export const useResetUserVariableSettings = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      ResetUserVariableSettingsError,
      ResetUserVariableSettingsVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useCuredaoContext();
  return reactQuery.useMutation<
    undefined,
    ResetUserVariableSettingsError,
    ResetUserVariableSettingsVariables
  >(
    (variables: ResetUserVariableSettingsVariables) =>
      fetchResetUserVariableSettings({ ...fetcherOptions, ...variables }),
    options
  );
};

export type GetVariableCategoriesError = Fetcher.ErrorWrapper<undefined>;

export type GetVariableCategoriesResponse = Schemas.VariableCategory[];

export type GetVariableCategoriesVariables = CuredaoContext["fetcherOptions"];

/**
 * The variable categories include Activity, Causes of Illness, Cognitive Performance, Conditions, Environment, Foods, Location, Miscellaneous, Mood, Nutrition, Physical Activity, Physique, Sleep, Social Interactions, Symptoms, Treatments, Vital Signs, and Goals.
 */
export const fetchGetVariableCategories = (
  variables: GetVariableCategoriesVariables
) =>
  curedaoFetch<
    GetVariableCategoriesResponse,
    GetVariableCategoriesError,
    undefined,
    {},
    {},
    {}
  >({ url: "/v3/variableCategories", method: "get", ...variables });

/**
 * The variable categories include Activity, Causes of Illness, Cognitive Performance, Conditions, Environment, Foods, Location, Miscellaneous, Mood, Nutrition, Physical Activity, Physique, Sleep, Social Interactions, Symptoms, Treatments, Vital Signs, and Goals.
 */
export const useGetVariableCategories = (
  variables: GetVariableCategoriesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetVariableCategoriesResponse,
      GetVariableCategoriesError,
      GetVariableCategoriesResponse
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useCuredaoContext(options);
  return reactQuery.useQuery<
    GetVariableCategoriesResponse,
    GetVariableCategoriesError,
    GetVariableCategoriesResponse
  >(
    queryKeyFn({
      path: "/v3/variableCategories",
      operationId: "getVariableCategories",
      variables,
    }),
    () => fetchGetVariableCategories({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type PostVoteQueryParams = {
  /*
   * User's id
   */
  userId?: number;
};

export type PostVoteError = Fetcher.ErrorWrapper<undefined>;

export type PostVoteVariables = {
  body: Schemas.Vote;
  queryParams?: PostVoteQueryParams;
} & CuredaoContext["fetcherOptions"];

/**
 * I am really good at finding correlations and even compensating for various onset delays and durations of action. However, you are much better than me at knowing if there's a way that a given factor could plausibly influence an outcome. You can help me learn and get better at my predictions by pressing the thumbs down button for relationships that you think are coincidences and thumbs up once that make logic sense.
 */
export const fetchPostVote = (variables: PostVoteVariables) =>
  curedaoFetch<
    Schemas.CommonResponse,
    PostVoteError,
    Schemas.Vote,
    {},
    PostVoteQueryParams,
    {}
  >({ url: "/v3/votes", method: "post", ...variables });

/**
 * I am really good at finding correlations and even compensating for various onset delays and durations of action. However, you are much better than me at knowing if there's a way that a given factor could plausibly influence an outcome. You can help me learn and get better at my predictions by pressing the thumbs down button for relationships that you think are coincidences and thumbs up once that make logic sense.
 */
export const usePostVote = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CommonResponse,
      PostVoteError,
      PostVoteVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useCuredaoContext();
  return reactQuery.useMutation<
    Schemas.CommonResponse,
    PostVoteError,
    PostVoteVariables
  >(
    (variables: PostVoteVariables) =>
      fetchPostVote({ ...fetcherOptions, ...variables }),
    options
  );
};

export type DeleteVoteQueryParams = {
  /*
   * User's id
   */
  userId?: number;
};

export type DeleteVoteError = Fetcher.ErrorWrapper<undefined>;

export type DeleteVoteVariables = {
  queryParams?: DeleteVoteQueryParams;
} & CuredaoContext["fetcherOptions"];

/**
 * Delete previously posted vote
 */
export const fetchDeleteVote = (variables: DeleteVoteVariables) =>
  curedaoFetch<
    Schemas.CommonResponse,
    DeleteVoteError,
    undefined,
    {},
    DeleteVoteQueryParams,
    {}
  >({ url: "/v3/votes/delete", method: "delete", ...variables });

/**
 * Delete previously posted vote
 */
export const useDeleteVote = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CommonResponse,
      DeleteVoteError,
      DeleteVoteVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useCuredaoContext();
  return reactQuery.useMutation<
    Schemas.CommonResponse,
    DeleteVoteError,
    DeleteVoteVariables
  >(
    (variables: DeleteVoteVariables) =>
      fetchDeleteVote({ ...fetcherOptions, ...variables }),
    options
  );
};

export type GetStudyQueryParams = {
  /*
   * Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
   */
  causeVariableName?: string;
  /*
   * Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
   */
  effectVariableName?: string;
  /*
   * User's id
   */
  userId?: number;
  /*
   * Your CureDAO client id can be obtained by creating an app at https://builder.curedao.org
   */
  clientId?: string;
  /*
   * Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
   */
  includeCharts?: boolean;
  /*
   * Recalculate instead of using cached analysis
   */
  recalculate?: boolean;
  /*
   * Client id for the study you want
   */
  studyId?: string;
};

export type GetStudyError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Schemas.JsonErrorResponse;
}>;

export type GetStudyVariables = {
  queryParams?: GetStudyQueryParams;
} & CuredaoContext["fetcherOptions"];

/**
 * Get Study
 */
export const fetchGetStudy = (variables: GetStudyVariables) =>
  curedaoFetch<
    Schemas.Study,
    GetStudyError,
    undefined,
    {},
    GetStudyQueryParams,
    {}
  >({ url: "/v4/study", method: "get", ...variables });

/**
 * Get Study
 */
export const useGetStudy = (
  variables: GetStudyVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.Study, GetStudyError, Schemas.Study>,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useCuredaoContext(options);
  return reactQuery.useQuery<Schemas.Study, GetStudyError, Schemas.Study>(
    queryKeyFn({ path: "/v4/study", operationId: "getStudy", variables }),
    () => fetchGetStudy({ ...fetcherOptions, ...variables }),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type QueryOperation =
  | {
      path: "/v3/units";
      operationId: "getUnits";
      variables: GetUnitsVariables;
    }
  | {
      path: "/v3/variables";
      operationId: "getVariables";
      variables: GetVariablesVariables;
    }
  | {
      path: "/v3/measurements";
      operationId: "getMeasurements";
      variables: GetMeasurementsVariables;
    }
  | {
      path: "/v3/appSettings";
      operationId: "getAppSettings";
      variables: GetAppSettingsVariables;
    }
  | {
      path: "/v3/connect/mobile";
      operationId: "getMobileConnectPage";
      variables: GetMobileConnectPageVariables;
    }
  | {
      path: "/v3/connectors/list";
      operationId: "getConnectors";
      variables: GetConnectorsVariables;
    }
  | {
      path: "/v3/connectors/{connectorName}/connect";
      operationId: "connectConnector";
      variables: ConnectConnectorVariables;
    }
  | {
      path: "/v3/connectors/{connectorName}/disconnect";
      operationId: "disconnectConnector";
      variables: DisconnectConnectorVariables;
    }
  | {
      path: "/v3/connectors/{connectorName}/update";
      operationId: "updateConnector";
      variables: UpdateConnectorVariables;
    }
  | {
      path: "/v3/correlations";
      operationId: "getCorrelations";
      variables: GetCorrelationsVariables;
    }
  | {
      path: "/v3/feed";
      operationId: "getFeed";
      variables: GetFeedVariables;
    }
  | {
      path: "/v3/integration.js";
      operationId: "getIntegrationJs";
      variables: GetIntegrationJsVariables;
    }
  | {
      path: "/v3/notificationPreferences";
      operationId: "getNotificationPreferences";
      variables: GetNotificationPreferencesVariables;
    }
  | {
      path: "/v3/oauth2/authorize";
      operationId: "getOauthAuthorizationCode";
      variables: GetOauthAuthorizationCodeVariables;
    }
  | {
      path: "/v3/oauth2/token";
      operationId: "getAccessToken";
      variables: GetAccessTokenVariables;
    }
  | {
      path: "/v3/shares";
      operationId: "getShares";
      variables: GetSharesVariables;
    }
  | {
      path: "/v3/studies";
      operationId: "getStudies";
      variables: GetStudiesVariables;
    }
  | {
      path: "/v3/studies/open";
      operationId: "getOpenStudies";
      variables: GetOpenStudiesVariables;
    }
  | {
      path: "/v3/studies/joined";
      operationId: "getStudiesJoined";
      variables: GetStudiesJoinedVariables;
    }
  | {
      path: "/v3/studies/created";
      operationId: "getStudiesCreated";
      variables: GetStudiesCreatedVariables;
    }
  | {
      path: "/v3/trackingReminderNotifications";
      operationId: "getTrackingReminderNotifications";
      variables: GetTrackingReminderNotificationsVariables;
    }
  | {
      path: "/v3/trackingReminders";
      operationId: "getTrackingReminders";
      variables: GetTrackingRemindersVariables;
    }
  | {
      path: "/v3/unitCategories";
      operationId: "getUnitCategories";
      variables: GetUnitCategoriesVariables;
    }
  | {
      path: "/v3/user";
      operationId: "getUser";
      variables: GetUserVariables;
    }
  | {
      path: "/v3/users";
      operationId: "getUsers";
      variables: GetUsersVariables;
    }
  | {
      path: "/v3/variableCategories";
      operationId: "getVariableCategories";
      variables: GetVariableCategoriesVariables;
    }
  | {
      path: "/v4/study";
      operationId: "getStudy";
      variables: GetStudyVariables;
    };
